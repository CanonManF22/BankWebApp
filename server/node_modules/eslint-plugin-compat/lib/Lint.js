"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.generateErrorName = generateErrorName;
exports.default = Lint;

var _providers = require("./providers");

function generateErrorName(_node) {
  if (_node.name) return _node.name;
  if (_node.property) return `${_node.object}.${_node.property}()`;
  return _node.object;
}
/**
 * Return false if a if a rule fails
 *
 * TODO: Eventually, targets will default to 'modern', ('chrome@50', safari@8)
 *       See https://github.com/amilajack/eslint-plugin-compat/wiki#release-200
 */


function Lint(eslintNode, targets = ['chrome', 'firefox', 'safari', 'edge'], polyfills) {
  // Find the corresponding rules for a eslintNode by it's astNodeType
  const failingRule = _providers.rules.filter(rule => rule.astNodeType === eslintNode.type && // v2 allowed users to select polyfills based off their caniuseId. This is
  // no longer supported. Keeping this here to avoid breaking changes.
  !polyfills.has(rule.id) && // Check if polyfill is provided
  !polyfills.has(rule.protoChainId)) // Find the first failing rule
  .find(rule => !rule.isValid(rule, eslintNode, targets));

  return failingRule ? {
    rule: failingRule,
    isValid: false,
    unsupportedTargets: failingRule.getUnsupportedTargets(failingRule, targets)
  } : {
    rule: {},
    unsupportedTargets: [],
    isValid: true
  };
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9MaW50LmpzIl0sIm5hbWVzIjpbImdlbmVyYXRlRXJyb3JOYW1lIiwiX25vZGUiLCJuYW1lIiwicHJvcGVydHkiLCJvYmplY3QiLCJMaW50IiwiZXNsaW50Tm9kZSIsInRhcmdldHMiLCJwb2x5ZmlsbHMiLCJmYWlsaW5nUnVsZSIsInJ1bGVzIiwiZmlsdGVyIiwicnVsZSIsImFzdE5vZGVUeXBlIiwidHlwZSIsImhhcyIsImlkIiwicHJvdG9DaGFpbklkIiwiZmluZCIsImlzVmFsaWQiLCJ1bnN1cHBvcnRlZFRhcmdldHMiLCJnZXRVbnN1cHBvcnRlZFRhcmdldHMiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQ0E7O0FBR08sU0FBU0EsaUJBQVQsQ0FBMkJDLEtBQTNCLEVBQWdEO0FBQ3JELE1BQUlBLEtBQUssQ0FBQ0MsSUFBVixFQUFnQixPQUFPRCxLQUFLLENBQUNDLElBQWI7QUFDaEIsTUFBSUQsS0FBSyxDQUFDRSxRQUFWLEVBQW9CLE9BQVEsR0FBRUYsS0FBSyxDQUFDRyxNQUFPLElBQUdILEtBQUssQ0FBQ0UsUUFBUyxJQUF6QztBQUNwQixTQUFPRixLQUFLLENBQUNHLE1BQWI7QUFDRDtBQUVEOzs7Ozs7OztBQU1lLFNBQVNDLElBQVQsQ0FDYkMsVUFEYSxFQUViQyxPQUFnQixHQUFHLENBQUMsUUFBRCxFQUFXLFNBQVgsRUFBc0IsUUFBdEIsRUFBZ0MsTUFBaEMsQ0FGTixFQUdiQyxTQUhhLEVBSUU7QUFDZjtBQUNBLFFBQU1DLFdBQVcsR0FBR0MsaUJBQ2pCQyxNQURpQixDQUVmQyxJQUFELElBQ0VBLElBQUksQ0FBQ0MsV0FBTCxLQUFxQlAsVUFBVSxDQUFDUSxJQUFoQyxJQUNBO0FBQ0E7QUFDQSxHQUFDTixTQUFTLENBQUNPLEdBQVYsQ0FBY0gsSUFBSSxDQUFDSSxFQUFuQixDQUhELElBSUE7QUFDQSxHQUFDUixTQUFTLENBQUNPLEdBQVYsQ0FBY0gsSUFBSSxDQUFDSyxZQUFuQixDQVJhLEVBVWxCO0FBVmtCLEdBV2pCQyxJQVhpQixDQVdYTixJQUFELElBQXlCLENBQUNBLElBQUksQ0FBQ08sT0FBTCxDQUFhUCxJQUFiLEVBQW1CTixVQUFuQixFQUErQkMsT0FBL0IsQ0FYZCxDQUFwQjs7QUFhQSxTQUFPRSxXQUFXLEdBQ2Q7QUFDRUcsSUFBQUEsSUFBSSxFQUFFSCxXQURSO0FBRUVVLElBQUFBLE9BQU8sRUFBRSxLQUZYO0FBR0VDLElBQUFBLGtCQUFrQixFQUFFWCxXQUFXLENBQUNZLHFCQUFaLENBQ2xCWixXQURrQixFQUVsQkYsT0FGa0I7QUFIdEIsR0FEYyxHQVNkO0FBQ0VLLElBQUFBLElBQUksRUFBRSxFQURSO0FBRUVRLElBQUFBLGtCQUFrQixFQUFFLEVBRnRCO0FBR0VELElBQUFBLE9BQU8sRUFBRTtBQUhYLEdBVEo7QUFjRCIsInNvdXJjZXNDb250ZW50IjpbIi8vIEBmbG93XG5pbXBvcnQgeyBydWxlcyB9IGZyb20gJy4vcHJvdmlkZXJzJztcbmltcG9ydCB0eXBlIHsgTm9kZSwgRVNMaW50Tm9kZSwgVGFyZ2V0cywgaXNWYWxpZE9iamVjdCB9IGZyb20gJy4vTGludFR5cGVzJztcblxuZXhwb3J0IGZ1bmN0aW9uIGdlbmVyYXRlRXJyb3JOYW1lKF9ub2RlOiBOb2RlKTogc3RyaW5nIHtcbiAgaWYgKF9ub2RlLm5hbWUpIHJldHVybiBfbm9kZS5uYW1lO1xuICBpZiAoX25vZGUucHJvcGVydHkpIHJldHVybiBgJHtfbm9kZS5vYmplY3R9LiR7X25vZGUucHJvcGVydHl9KClgO1xuICByZXR1cm4gX25vZGUub2JqZWN0O1xufVxuXG4vKipcbiAqIFJldHVybiBmYWxzZSBpZiBhIGlmIGEgcnVsZSBmYWlsc1xuICpcbiAqIFRPRE86IEV2ZW50dWFsbHksIHRhcmdldHMgd2lsbCBkZWZhdWx0IHRvICdtb2Rlcm4nLCAoJ2Nocm9tZUA1MCcsIHNhZmFyaUA4KVxuICogICAgICAgU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9hbWlsYWphY2svZXNsaW50LXBsdWdpbi1jb21wYXQvd2lraSNyZWxlYXNlLTIwMFxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBMaW50KFxuICBlc2xpbnROb2RlOiBFU0xpbnROb2RlLFxuICB0YXJnZXRzOiBUYXJnZXRzID0gWydjaHJvbWUnLCAnZmlyZWZveCcsICdzYWZhcmknLCAnZWRnZSddLFxuICBwb2x5ZmlsbHM6IFNldDxzdHJpbmc+XG4pOiBpc1ZhbGlkT2JqZWN0IHtcbiAgLy8gRmluZCB0aGUgY29ycmVzcG9uZGluZyBydWxlcyBmb3IgYSBlc2xpbnROb2RlIGJ5IGl0J3MgYXN0Tm9kZVR5cGVcbiAgY29uc3QgZmFpbGluZ1J1bGUgPSBydWxlc1xuICAgIC5maWx0ZXIoXG4gICAgICAocnVsZTogTm9kZSk6IGJvb2xlYW4gPT5cbiAgICAgICAgcnVsZS5hc3ROb2RlVHlwZSA9PT0gZXNsaW50Tm9kZS50eXBlICYmXG4gICAgICAgIC8vIHYyIGFsbG93ZWQgdXNlcnMgdG8gc2VsZWN0IHBvbHlmaWxscyBiYXNlZCBvZmYgdGhlaXIgY2FuaXVzZUlkLiBUaGlzIGlzXG4gICAgICAgIC8vIG5vIGxvbmdlciBzdXBwb3J0ZWQuIEtlZXBpbmcgdGhpcyBoZXJlIHRvIGF2b2lkIGJyZWFraW5nIGNoYW5nZXMuXG4gICAgICAgICFwb2x5ZmlsbHMuaGFzKHJ1bGUuaWQpICYmXG4gICAgICAgIC8vIENoZWNrIGlmIHBvbHlmaWxsIGlzIHByb3ZpZGVkXG4gICAgICAgICFwb2x5ZmlsbHMuaGFzKHJ1bGUucHJvdG9DaGFpbklkKVxuICAgIClcbiAgICAvLyBGaW5kIHRoZSBmaXJzdCBmYWlsaW5nIHJ1bGVcbiAgICAuZmluZCgocnVsZTogTm9kZSk6IGJvb2xlYW4gPT4gIXJ1bGUuaXNWYWxpZChydWxlLCBlc2xpbnROb2RlLCB0YXJnZXRzKSk7XG5cbiAgcmV0dXJuIGZhaWxpbmdSdWxlXG4gICAgPyB7XG4gICAgICAgIHJ1bGU6IGZhaWxpbmdSdWxlLFxuICAgICAgICBpc1ZhbGlkOiBmYWxzZSxcbiAgICAgICAgdW5zdXBwb3J0ZWRUYXJnZXRzOiBmYWlsaW5nUnVsZS5nZXRVbnN1cHBvcnRlZFRhcmdldHMoXG4gICAgICAgICAgZmFpbGluZ1J1bGUsXG4gICAgICAgICAgdGFyZ2V0c1xuICAgICAgICApXG4gICAgICB9XG4gICAgOiB7XG4gICAgICAgIHJ1bGU6IHt9LFxuICAgICAgICB1bnN1cHBvcnRlZFRhcmdldHM6IFtdLFxuICAgICAgICBpc1ZhbGlkOiB0cnVlXG4gICAgICB9O1xufVxuIl19