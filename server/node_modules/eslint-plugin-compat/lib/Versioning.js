"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = DetermineTargetsFromConfig;
exports.Versioning = Versioning;

var _browserslist = _interopRequireDefault(require("browserslist"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Determine the targets based on the browserslist config object
 */
function DetermineTargetsFromConfig(config) {
  if (Array.isArray(config)) {
    return (0, _browserslist.default)(config);
  }

  if (config && typeof config === 'object') {
    return (0, _browserslist.default)([...(config.production || []), ...(config.development || [])]);
  }

  return (0, _browserslist.default)();
}
/**
 * Take a list of targets returned from browserslist api, return the lowest version
 * version of each target
 */


function Versioning(targetslist) {
  return targetslist // Sort the targets by target name and then version number in ascending order
  .map(e => {
    const [target, version] = e.split(' ');
    return {
      target,
      version,
      parsedVersion: version === 'all' ? 0 : version.includes('-') ? parseFloat(version.split('-')[0]) : parseFloat(version)
    };
  }) // Sort the targets by target name and then version number in descending order
  // ex. [a@3, b@3, a@1] => [a@3, a@1, b@3]
  .sort((a, b) => {
    if (b.target === a.target) {
      // If any version === 'all', return 0. The only version of op_mini is 'all'
      // Otherwise, compare the versions
      return typeof b.parsedVersion === 'string' || typeof a.parsedVersion === 'string' ? 0 : b.parsedVersion - a.parsedVersion;
    }

    return b.target > a.target ? 1 : -1;
  }) // First last target always has the latest version
  .filter((e, i, items // Check if the current target is the last of its kind. If it is, then it
  // is most recent version
  ) => i + 1 === items.length || e.target !== items[i + 1].target);
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9WZXJzaW9uaW5nLmpzIl0sIm5hbWVzIjpbIkRldGVybWluZVRhcmdldHNGcm9tQ29uZmlnIiwiY29uZmlnIiwiQXJyYXkiLCJpc0FycmF5IiwicHJvZHVjdGlvbiIsImRldmVsb3BtZW50IiwiVmVyc2lvbmluZyIsInRhcmdldHNsaXN0IiwibWFwIiwiZSIsInRhcmdldCIsInZlcnNpb24iLCJzcGxpdCIsInBhcnNlZFZlcnNpb24iLCJpbmNsdWRlcyIsInBhcnNlRmxvYXQiLCJzb3J0IiwiYSIsImIiLCJmaWx0ZXIiLCJpIiwiaXRlbXMiLCJsZW5ndGgiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQ0E7Ozs7QUFTQTs7O0FBR2UsU0FBU0EsMEJBQVQsQ0FDYkMsTUFEYSxFQUVFO0FBQ2YsTUFBSUMsS0FBSyxDQUFDQyxPQUFOLENBQWNGLE1BQWQsQ0FBSixFQUEyQjtBQUN6QixXQUFPLDJCQUFhQSxNQUFiLENBQVA7QUFDRDs7QUFFRCxNQUFJQSxNQUFNLElBQUksT0FBT0EsTUFBUCxLQUFrQixRQUFoQyxFQUEwQztBQUN4QyxXQUFPLDJCQUFhLENBQ2xCLElBQUlBLE1BQU0sQ0FBQ0csVUFBUCxJQUFxQixFQUF6QixDQURrQixFQUVsQixJQUFJSCxNQUFNLENBQUNJLFdBQVAsSUFBc0IsRUFBMUIsQ0FGa0IsQ0FBYixDQUFQO0FBSUQ7O0FBRUQsU0FBTyw0QkFBUDtBQUNEO0FBRUQ7Ozs7OztBQUlPLFNBQVNDLFVBQVQsQ0FBb0JDLFdBQXBCLEVBQXVFO0FBQzVFLFNBQ0VBLFdBQVcsQ0FDVDtBQURTLEdBRVJDLEdBRkgsQ0FHS0MsQ0FBRCxJQUErQjtBQUM3QixVQUFNLENBQUNDLE1BQUQsRUFBU0MsT0FBVCxJQUFvQkYsQ0FBQyxDQUFDRyxLQUFGLENBQVEsR0FBUixDQUExQjtBQUNBLFdBQU87QUFDTEYsTUFBQUEsTUFESztBQUVMQyxNQUFBQSxPQUZLO0FBR0xFLE1BQUFBLGFBQWEsRUFDWEYsT0FBTyxLQUFLLEtBQVosR0FDSSxDQURKLEdBRUlBLE9BQU8sQ0FBQ0csUUFBUixDQUFpQixHQUFqQixJQUNBQyxVQUFVLENBQUNKLE9BQU8sQ0FBQ0MsS0FBUixDQUFjLEdBQWQsRUFBbUIsQ0FBbkIsQ0FBRCxDQURWLEdBRUFHLFVBQVUsQ0FBQ0osT0FBRDtBQVJYLEtBQVA7QUFVRCxHQWZMLEVBaUJFO0FBQ0E7QUFsQkYsR0FtQkdLLElBbkJILENBb0JJLENBQUNDLENBQUQsRUFBb0JDLENBQXBCLEtBQWtEO0FBQ2hELFFBQUlBLENBQUMsQ0FBQ1IsTUFBRixLQUFhTyxDQUFDLENBQUNQLE1BQW5CLEVBQTJCO0FBQ3pCO0FBQ0E7QUFDQSxhQUFPLE9BQU9RLENBQUMsQ0FBQ0wsYUFBVCxLQUEyQixRQUEzQixJQUNMLE9BQU9JLENBQUMsQ0FBQ0osYUFBVCxLQUEyQixRQUR0QixHQUVILENBRkcsR0FHSEssQ0FBQyxDQUFDTCxhQUFGLEdBQWtCSSxDQUFDLENBQUNKLGFBSHhCO0FBSUQ7O0FBQ0QsV0FBT0ssQ0FBQyxDQUFDUixNQUFGLEdBQVdPLENBQUMsQ0FBQ1AsTUFBYixHQUFzQixDQUF0QixHQUEwQixDQUFDLENBQWxDO0FBQ0QsR0E5QkwsRUFnQ0U7QUFoQ0YsR0FpQ0dTLE1BakNILENBa0NJLENBQUNWLENBQUQsRUFBb0JXLENBQXBCLEVBQStCQyxLQUEvQixDQUNFO0FBQ0E7QUFGRixPQUdFRCxDQUFDLEdBQUcsQ0FBSixLQUFVQyxLQUFLLENBQUNDLE1BQWhCLElBQTBCYixDQUFDLENBQUNDLE1BQUYsS0FBYVcsS0FBSyxDQUFDRCxDQUFDLEdBQUcsQ0FBTCxDQUFMLENBQWFWLE1BckMxRCxDQURGO0FBeUNEIiwic291cmNlc0NvbnRlbnQiOlsiLy8gQGZsb3dcbmltcG9ydCBicm93c2Vyc2xpc3QgZnJvbSAnYnJvd3NlcnNsaXN0JztcbmltcG9ydCB0eXBlIHsgQnJvd3Nlckxpc3RDb25maWcgfSBmcm9tICcuL3J1bGVzL2NvbXBhdCc7XG5cbnR5cGUgVGFyZ2V0TGlzdEl0ZW0gPSB7XG4gIHRhcmdldDogc3RyaW5nLFxuICBwYXJzZWRWZXJzaW9uOiBudW1iZXIsXG4gIHZlcnNpb246IHN0cmluZyB8ICdhbGwnXG59O1xuXG4vKipcbiAqIERldGVybWluZSB0aGUgdGFyZ2V0cyBiYXNlZCBvbiB0aGUgYnJvd3NlcnNsaXN0IGNvbmZpZyBvYmplY3RcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gRGV0ZXJtaW5lVGFyZ2V0c0Zyb21Db25maWcoXG4gIGNvbmZpZz86IEJyb3dzZXJMaXN0Q29uZmlnXG4pOiBBcnJheTxzdHJpbmc+IHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoY29uZmlnKSkge1xuICAgIHJldHVybiBicm93c2Vyc2xpc3QoY29uZmlnKTtcbiAgfVxuXG4gIGlmIChjb25maWcgJiYgdHlwZW9mIGNvbmZpZyA9PT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gYnJvd3NlcnNsaXN0KFtcbiAgICAgIC4uLihjb25maWcucHJvZHVjdGlvbiB8fCBbXSksXG4gICAgICAuLi4oY29uZmlnLmRldmVsb3BtZW50IHx8IFtdKVxuICAgIF0pO1xuICB9XG5cbiAgcmV0dXJuIGJyb3dzZXJzbGlzdCgpO1xufVxuXG4vKipcbiAqIFRha2UgYSBsaXN0IG9mIHRhcmdldHMgcmV0dXJuZWQgZnJvbSBicm93c2Vyc2xpc3QgYXBpLCByZXR1cm4gdGhlIGxvd2VzdCB2ZXJzaW9uXG4gKiB2ZXJzaW9uIG9mIGVhY2ggdGFyZ2V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBWZXJzaW9uaW5nKHRhcmdldHNsaXN0OiBBcnJheTxzdHJpbmc+KTogQXJyYXk8VGFyZ2V0TGlzdEl0ZW0+IHtcbiAgcmV0dXJuIChcbiAgICB0YXJnZXRzbGlzdFxuICAgICAgLy8gU29ydCB0aGUgdGFyZ2V0cyBieSB0YXJnZXQgbmFtZSBhbmQgdGhlbiB2ZXJzaW9uIG51bWJlciBpbiBhc2NlbmRpbmcgb3JkZXJcbiAgICAgIC5tYXAoXG4gICAgICAgIChlOiBzdHJpbmcpOiBUYXJnZXRMaXN0SXRlbSA9PiB7XG4gICAgICAgICAgY29uc3QgW3RhcmdldCwgdmVyc2lvbl0gPSBlLnNwbGl0KCcgJyk7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHRhcmdldCxcbiAgICAgICAgICAgIHZlcnNpb24sXG4gICAgICAgICAgICBwYXJzZWRWZXJzaW9uOlxuICAgICAgICAgICAgICB2ZXJzaW9uID09PSAnYWxsJ1xuICAgICAgICAgICAgICAgID8gMFxuICAgICAgICAgICAgICAgIDogdmVyc2lvbi5pbmNsdWRlcygnLScpXG4gICAgICAgICAgICAgICAgPyBwYXJzZUZsb2F0KHZlcnNpb24uc3BsaXQoJy0nKVswXSlcbiAgICAgICAgICAgICAgICA6IHBhcnNlRmxvYXQodmVyc2lvbilcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICApXG4gICAgICAvLyBTb3J0IHRoZSB0YXJnZXRzIGJ5IHRhcmdldCBuYW1lIGFuZCB0aGVuIHZlcnNpb24gbnVtYmVyIGluIGRlc2NlbmRpbmcgb3JkZXJcbiAgICAgIC8vIGV4LiBbYUAzLCBiQDMsIGFAMV0gPT4gW2FAMywgYUAxLCBiQDNdXG4gICAgICAuc29ydChcbiAgICAgICAgKGE6IFRhcmdldExpc3RJdGVtLCBiOiBUYXJnZXRMaXN0SXRlbSk6IG51bWJlciA9PiB7XG4gICAgICAgICAgaWYgKGIudGFyZ2V0ID09PSBhLnRhcmdldCkge1xuICAgICAgICAgICAgLy8gSWYgYW55IHZlcnNpb24gPT09ICdhbGwnLCByZXR1cm4gMC4gVGhlIG9ubHkgdmVyc2lvbiBvZiBvcF9taW5pIGlzICdhbGwnXG4gICAgICAgICAgICAvLyBPdGhlcndpc2UsIGNvbXBhcmUgdGhlIHZlcnNpb25zXG4gICAgICAgICAgICByZXR1cm4gdHlwZW9mIGIucGFyc2VkVmVyc2lvbiA9PT0gJ3N0cmluZycgfHxcbiAgICAgICAgICAgICAgdHlwZW9mIGEucGFyc2VkVmVyc2lvbiA9PT0gJ3N0cmluZydcbiAgICAgICAgICAgICAgPyAwXG4gICAgICAgICAgICAgIDogYi5wYXJzZWRWZXJzaW9uIC0gYS5wYXJzZWRWZXJzaW9uO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gYi50YXJnZXQgPiBhLnRhcmdldCA/IDEgOiAtMTtcbiAgICAgICAgfVxuICAgICAgKVxuICAgICAgLy8gRmlyc3QgbGFzdCB0YXJnZXQgYWx3YXlzIGhhcyB0aGUgbGF0ZXN0IHZlcnNpb25cbiAgICAgIC5maWx0ZXIoXG4gICAgICAgIChlOiBUYXJnZXRMaXN0SXRlbSwgaTogbnVtYmVyLCBpdGVtczogQXJyYXk8VGFyZ2V0TGlzdEl0ZW0+KTogYm9vbGVhbiA9PlxuICAgICAgICAgIC8vIENoZWNrIGlmIHRoZSBjdXJyZW50IHRhcmdldCBpcyB0aGUgbGFzdCBvZiBpdHMga2luZC4gSWYgaXQgaXMsIHRoZW4gaXRcbiAgICAgICAgICAvLyBpcyBtb3N0IHJlY2VudCB2ZXJzaW9uXG4gICAgICAgICAgaSArIDEgPT09IGl0ZW1zLmxlbmd0aCB8fCBlLnRhcmdldCAhPT0gaXRlbXNbaSArIDFdLnRhcmdldFxuICAgICAgKVxuICApO1xufVxuIl19